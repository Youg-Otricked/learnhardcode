{
  "id": "lesson59.json",
  "title": "OOP [7] â€“ virtual & override",
  "description": "Without `virtual`, the method that gets called depends only on the **static type** (the type of the variable).\n\nWith `virtual`, the call depends on the **dynamic type** (the actual object).\n\n```cpp\nclass Animal {\npublic:\n    virtual void speak() {\n        std::cout << \"...\";\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void speak() override {\n        std::cout << \"woof\";\n    }\n};\n\nvoid makeSpeak(Animal& a) {\n    a.speak(); // calls Dog::speak if a is actually a Dog\n}\n```\n\n- `virtual` on the base method enables **runtime polymorphism**.\n- `override` on the derived method tells the compiler this is meant to replace a virtual method from the base.\n\n---\n\n## Your task\n\nCBit OS wants to log messages using a base class pointer.\n\n- Make a base class `Logger` with a **public virtual** method `void log(const std::string& msg)` that prints `\"[base] \"` followed by `msg` and a newline.\n- Make a class `ConsoleLogger` that **inherits publicly** from `Logger`.\n- In `ConsoleLogger`, override `log` so it prints `\"[console] \"` followed by `msg` and a newline.\n\n`main` will call `log` through a `Logger*` pointer. Make sure the overridden version is used.\n",
  "starterCode": "#include <iostream>\n#include <string>\n\n// define Logger and ConsoleLogger here\n\nint main() {\n    ConsoleLogger console;\n    Logger* loggerPtr = &console; // base-class pointer to derived object\n\n    loggerPtr->log(\"Hello\");\n}\n",
  "expectedOutput": "[console] Hello\n",
  "mustContain": "[console] Hello",
  "nextLesson": "lesson60.json",
  "previous": "lesson58.json",
  "showButtons": false,
  "correct": "",
  "b1t": "",
  "b2t": "",
  "b3t": "",
  "b4t": "",
  "runHarness": "",
  "submitHarness": "",
  "solution": "",
  "hint": "Remember: `virtual` goes on the base method. Use `void log(const std::string& msg) override` in `ConsoleLogger` so the compiler knows you are overriding."
}